{"ast":null,"code":"/*!\n * react-panresponder-web v1.0.0\n * (c) 2018-present Javier Marquez\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react-dom/unstable-native-dependencies')) : typeof define === 'function' && define.amd ? define(['react-dom/unstable-native-dependencies'], factory) : global.PanResponder = factory(global.UnstableDependencies);\n})(this, function (ReactDOMUnstableNativeDependencies) {\n  'use strict';\n\n  var ReactDOMUnstableNativeDependencies__default = 'default' in ReactDOMUnstableNativeDependencies ? ReactDOMUnstableNativeDependencies['default'] : ReactDOMUnstableNativeDependencies;\n\n  /**\r\n   * Copyright (c) 2015-present, Nicolas Gallagher.\r\n   *\r\n   * This source code is licensed under the MIT license found in the\r\n   * LICENSE file in the root directory of this source tree.\r\n   *\r\n   */\n  var _requestIdleCallback = function _requestIdleCallback(cb, options) {\n    return setTimeout(function () {\n      var start = Date.now();\n      cb({\n        didTimeout: false,\n        timeRemaining: function timeRemaining() {\n          return Math.max(0, 50 - (Date.now() - start));\n        }\n      });\n    }, 1);\n  };\n  var _cancelIdleCallback = function _cancelIdleCallback(id) {\n    clearTimeout(id);\n  };\n  var isSupported = typeof window.requestIdleCallback !== 'undefined';\n  var requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;\n  var cancelIdleCallback = isSupported ? window.cancelIdleCallback : _cancelIdleCallback;\n\n  /**\r\n   * Copyright (c) 2016-present, Nicolas Gallagher.\r\n   * Copyright (c) 2015-present, Facebook, Inc.\r\n   *\r\n   * This source code is licensed under the MIT license found in the\r\n   * LICENSE file in the root directory of this source tree.\r\n   *\r\n   */\n  var InteractionManager = {\n    Events: {\n      interactionStart: 'interactionStart',\n      interactionComplete: 'interactionComplete'\n    },\n    /**\r\n     * Schedule a function to run after all interactions have completed.\r\n     */\n    runAfterInteractions: function runAfterInteractions(task) {\n      var handle;\n      var promise = new Promise(function (resolve) {\n        handle = requestIdleCallback(function () {\n          if (task) {\n            resolve(task());\n          }\n        });\n      });\n      return {\n        then: promise.then.bind(promise),\n        done: promise.then.bind(promise),\n        cancel: function cancel() {\n          cancelIdleCallback(handle);\n        }\n      };\n    },\n    /**\r\n     * Notify manager that an interaction has started.\r\n     */\n    createInteractionHandle: function createInteractionHandle() {\n      return 1;\n    },\n    /**\r\n     * Notify manager that an interaction has completed.\r\n     */\n    clearInteractionHandle: function clearInteractionHandle(handle) {\n      !handle && console.warn('Must provide a handle to clear.');\n    },\n    addListener: function addListener() {}\n  };\n  var TouchHistoryMath = {\n    /**\r\n     * This code is optimized and not intended to look beautiful. This allows\r\n     * computing of touch centroids that have moved after `touchesChangedAfter`\r\n     * timeStamp. You can compute the current centroid involving all touches\r\n     * moves after `touchesChangedAfter`, or you can compute the previous\r\n     * centroid of all touches that were moved after `touchesChangedAfter`.\r\n     *\r\n     * @param {TouchHistoryMath} touchHistory Standard Responder touch track\r\n     * data.\r\n     * @param {number} touchesChangedAfter timeStamp after which moved touches\r\n     * are considered \"actively moving\" - not just \"active\".\r\n     * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.\r\n     * @param {boolean} ofCurrent Compute current centroid for actively moving\r\n     * touches vs. previous centroid of now actively moving touches.\r\n     * @return {number} value of centroid in specified dimension.\r\n     */\n    centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {\n      var touchBank = touchHistory.touchBank;\n      var total = 0;\n      var count = 0;\n      var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;\n      if (oneTouchData !== null) {\n        if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {\n          total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;\n          count = 1;\n        }\n      } else {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrack = touchBank[i];\n          if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {\n            var toAdd = void 0; // Yuck, program temporarily in invalid state.\n\n            if (ofCurrent && isXAxis) {\n              toAdd = touchTrack.currentPageX;\n            } else if (ofCurrent && !isXAxis) {\n              toAdd = touchTrack.currentPageY;\n            } else if (!ofCurrent && isXAxis) {\n              toAdd = touchTrack.previousPageX;\n            } else {\n              toAdd = touchTrack.previousPageY;\n            }\n            total += toAdd;\n            count++;\n          }\n        }\n      }\n      return count > 0 ? total / count : TouchHistoryMath.noCentroid;\n    },\n    currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {\n      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true,\n      // isXAxis\n      true);\n    },\n    currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {\n      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false,\n      // isXAxis\n      true);\n    },\n    previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {\n      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true,\n      // isXAxis\n      false);\n    },\n    previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {\n      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false,\n      // isXAxis\n      false);\n    },\n    currentCentroidX: function currentCentroidX(touchHistory) {\n      return TouchHistoryMath.centroidDimension(touchHistory, 0,\n      // touchesChangedAfter\n      true,\n      // isXAxis\n      true);\n    },\n    currentCentroidY: function currentCentroidY(touchHistory) {\n      return TouchHistoryMath.centroidDimension(touchHistory, 0,\n      // touchesChangedAfter\n      false,\n      // isXAxis\n      true);\n    },\n    noCentroid: -1\n  };\n\n  /**\r\n   * Copyright (c) 2013-present, Facebook, Inc.\r\n   *\r\n   * This source code is licensed under the MIT license found in the\r\n   * LICENSE file in the root directory of this source tree.\r\n   */\n  var currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;\n  var currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;\n  var previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;\n  var previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;\n  var currentCentroidX = TouchHistoryMath.currentCentroidX;\n  var currentCentroidY = TouchHistoryMath.currentCentroidY;\n  /**\r\n   * `PanResponder` reconciles several touches into a single gesture. It makes\r\n   * single-touch gestures resilient to extra touches, and can be used to\r\n   * recognize simple multi-touch gestures.\r\n   *\r\n   * By default, `PanResponder` holds an `InteractionManager` handle to block\r\n   * long-running JS events from interrupting active gestures.\r\n   *\r\n   * It provides a predictable wrapper of the responder handlers provided by the\r\n   * [gesture responder system](docs/gesture-responder-system.html).\r\n   * For each handler, it provides a new `gestureState` object alongside the\r\n   * native event object:\r\n   *\r\n   * ```\r\n   * onPanResponderMove: (event, gestureState) => {}\r\n   * ```\r\n   *\r\n   * A native event is a synthetic touch event with the following form:\r\n   *\r\n   *  - `nativeEvent`\r\n   *      + `changedTouches` - Array of all touch events that have changed since the last event\r\n   *      + `identifier` - The ID of the touch\r\n   *      + `locationX` - The X position of the touch, relative to the element\r\n   *      + `locationY` - The Y position of the touch, relative to the element\r\n   *      + `pageX` - The X position of the touch, relative to the root element\r\n   *      + `pageY` - The Y position of the touch, relative to the root element\r\n   *      + `target` - The node id of the element receiving the touch event\r\n   *      + `timestamp` - A time identifier for the touch, useful for velocity calculation\r\n   *      + `touches` - Array of all current touches on the screen\r\n   *\r\n   * A `gestureState` object has the following:\r\n   *\r\n   *  - `stateID` - ID of the gestureState- persisted as long as there at least\r\n   *     one touch on screen\r\n   *  - `moveX` - the latest screen coordinates of the recently-moved touch\r\n   *  - `moveY` - the latest screen coordinates of the recently-moved touch\r\n   *  - `x0` - the screen coordinates of the responder grant\r\n   *  - `y0` - the screen coordinates of the responder grant\r\n   *  - `dx` - accumulated distance of the gesture since the touch started\r\n   *  - `dy` - accumulated distance of the gesture since the touch started\r\n   *  - `vx` - current velocity of the gesture\r\n   *  - `vy` - current velocity of the gesture\r\n   *  - `numberActiveTouches` - Number of touches currently on screen\r\n   *\r\n   * ### Basic Usage\r\n   *\r\n   * ```\r\n   *   componentWillMount: function() {\r\n   *     this._panResponder = PanResponder.create({\r\n   *       // Ask to be the responder:\r\n   *       onStartShouldSetPanResponder: (evt, gestureState) => true,\r\n   *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\r\n   *       onMoveShouldSetPanResponder: (evt, gestureState) => true,\r\n   *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\r\n   *\r\n   *       onPanResponderGrant: (evt, gestureState) => {\r\n   *         // The gesture has started. Show visual feedback so the user knows\r\n   *         // what is happening!\r\n   *\r\n   *         // gestureState.d{x,y} will be set to zero now\r\n   *       },\r\n   *       onPanResponderMove: (evt, gestureState) => {\r\n   *         // The most recent move distance is gestureState.move{X,Y}\r\n   *\r\n   *         // The accumulated gesture distance since becoming responder is\r\n   *         // gestureState.d{x,y}\r\n   *       },\r\n   *       onPanResponderTerminationRequest: (evt, gestureState) => true,\r\n   *       onPanResponderRelease: (evt, gestureState) => {\r\n   *         // The user has released all touches while this view is the\r\n   *         // responder. This typically means a gesture has succeeded\r\n   *       },\r\n   *       onPanResponderTerminate: (evt, gestureState) => {\r\n   *         // Another component has become the responder, so this gesture\r\n   *         // should be cancelled\r\n   *       },\r\n   *       onShouldBlockNativeResponder: (evt, gestureState) => {\r\n   *         // Returns whether this component should block native components from becoming the JS\r\n   *         // responder. Returns true by default. Is currently only supported on android.\r\n   *         return true;\r\n   *       },\r\n   *     });\r\n   *   },\r\n   *\r\n   *   render: function() {\r\n   *     return (\r\n   *       <View {...this._panResponder.panHandlers} />\r\n   *     );\r\n   *   },\r\n   *\r\n   * ```\r\n   *\r\n   * ### Working Example\r\n   *\r\n   * To see it in action, try the\r\n   * [PanResponder example in RNTester](https://github.com/facebook/react-native/blob/master/RNTester/js/PanResponderExample.js)\r\n   */\n\n  var PanResponder = {\n    /**\r\n     *\r\n     * A graphical explanation of the touch data flow:\r\n     *\r\n     * +----------------------------+             +--------------------------------+\r\n     * | ResponderTouchHistoryStore |             |TouchHistoryMath                |\r\n     * +----------------------------+             +----------+---------------------+\r\n     * |Global store of touchHistory|             |Allocation-less math util       |\r\n     * |including activeness, start |             |on touch history (centroids     |\r\n     * |position, prev/cur position.|             |and multitouch movement etc)    |\r\n     * |                            |             |                                |\r\n     * +----^-----------------------+             +----^---------------------------+\r\n     *      |                                          |\r\n     *      | (records relevant history                |\r\n     *      |  of touches relevant for                 |\r\n     *      |  implementing higher level               |\r\n     *      |  gestures)                               |\r\n     *      |                                          |\r\n     * +----+-----------------------+             +----|---------------------------+\r\n     * | ResponderEventPlugin       |             |    |   Your App/Component      |\r\n     * +----------------------------+             +----|---------------------------+\r\n     * |Negotiates which view gets  | Low level   |    |             High level    |\r\n     * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |\r\n     * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |\r\n     * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|\r\n     * +----------------------------+ attached to |  |         |     distance and  |\r\n     *                                 each event |  +---------+     velocity.     |\r\n     *                                            |                                |\r\n     *                                            |                                |\r\n     *                                            +--------------------------------+\r\n     *\r\n     *\r\n     *\r\n     * Gesture that calculates cumulative movement over time in a way that just\r\n     * \"does the right thing\" for multiple touches. The \"right thing\" is very\r\n     * nuanced. When moving two touches in opposite directions, the cumulative\r\n     * distance is zero in each dimension. When two touches move in parallel five\r\n     * pixels in the same direction, the cumulative distance is five, not ten. If\r\n     * two touches start, one moves five in a direction, then stops and the other\r\n     * touch moves fives in the same direction, the cumulative distance is ten.\r\n     *\r\n     * This logic requires a kind of processing of time \"clusters\" of touch events\r\n     * so that two touch moves that essentially occur in parallel but move every\r\n     * other frame respectively, are considered part of the same movement.\r\n     *\r\n     * Explanation of some of the non-obvious fields:\r\n     *\r\n     * - moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is\r\n     *   invalid. If a move event has been observed, `(moveX, moveY)` is the\r\n     *   centroid of the most recently moved \"cluster\" of active touches.\r\n     *   (Currently all move have the same timeStamp, but later we should add some\r\n     *   threshold for what is considered to be \"moving\"). If a palm is\r\n     *   accidentally counted as a touch, but a finger is moving greatly, the palm\r\n     *   will move slightly, but we only want to count the single moving touch.\r\n     * - x0/y0: Centroid location (non-cumulative) at the time of becoming\r\n     *   responder.\r\n     * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch\r\n     *   distance. Accounts for touch moves that are clustered together in time,\r\n     *   moving the same direction. Only valid when currently responder (otherwise,\r\n     *   it only represents the drag distance below the threshold).\r\n     * - vx/vy: Velocity.\r\n     */\n    _initializeGestureState: function _initializeGestureState(gestureState) {\n      gestureState.moveX = 0;\n      gestureState.moveY = 0;\n      gestureState.x0 = 0;\n      gestureState.y0 = 0;\n      gestureState.dx = 0;\n      gestureState.dy = 0;\n      gestureState.vx = 0;\n      gestureState.vy = 0;\n      gestureState.numberActiveTouches = 0; // All `gestureState` accounts for timeStamps up until:\n\n      gestureState._accountsForMovesUpTo = 0;\n    },\n    /**\r\n     * This is nuanced and is necessary. It is incorrect to continuously take all\r\n     * active *and* recently moved touches, find the centroid, and track how that\r\n     * result changes over time. Instead, we must take all recently moved\r\n     * touches, and calculate how the centroid has changed just for those\r\n     * recently moved touches, and append that change to an accumulator. This is\r\n     * to (at least) handle the case where the user is moving three fingers, and\r\n     * then one of the fingers stops but the other two continue.\r\n     *\r\n     * This is very different than taking all of the recently moved touches and\r\n     * storing their centroid as `dx/dy`. For correctness, we must *accumulate\r\n     * changes* in the centroid of recently moved touches.\r\n     *\r\n     * There is also some nuance with how we handle multiple moved touches in a\r\n     * single event. With the way `ReactNativeEventEmitter` dispatches touches as\r\n     * individual events, multiple touches generate two 'move' events, each of\r\n     * them triggering `onResponderMove`. But with the way `PanResponder` works,\r\n     * all of the gesture inference is performed on the first dispatch, since it\r\n     * looks at all of the touches (even the ones for which there hasn't been a\r\n     * native dispatch yet). Therefore, `PanResponder` does not call\r\n     * `onResponderMove` passed the first dispatch. This diverges from the\r\n     * typical responder callback pattern (without using `PanResponder`), but\r\n     * avoids more dispatches than necessary.\r\n     */\n    _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {\n      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n      gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);\n      gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);\n      var movedAfter = gestureState._accountsForMovesUpTo;\n      var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n      var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n      var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n      var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n      var nextDX = gestureState.dx + (x - prevX);\n      var nextDY = gestureState.dy + (y - prevY); // TODO: This must be filtered intelligently.\n\n      var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;\n      gestureState.vx = (nextDX - gestureState.dx) / dt;\n      gestureState.vy = (nextDY - gestureState.dy) / dt;\n      gestureState.dx = nextDX;\n      gestureState.dy = nextDY;\n      gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n    },\n    /**\r\n     * @param {object} config Enhanced versions of all of the responder callbacks\r\n     * that provide not only the typical `ResponderSyntheticEvent`, but also the\r\n     * `PanResponder` gesture state.  Simply replace the word `Responder` with\r\n     * `PanResponder` in each of the typical `onResponder*` callbacks. For\r\n     * example, the `config` object would look like:\r\n     *\r\n     *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`\r\n     *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`\r\n     *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`\r\n     *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`\r\n     *  - `onPanResponderReject: (e, gestureState) => {...}`\r\n     *  - `onPanResponderGrant: (e, gestureState) => {...}`\r\n     *  - `onPanResponderStart: (e, gestureState) => {...}`\r\n     *  - `onPanResponderEnd: (e, gestureState) => {...}`\r\n     *  - `onPanResponderRelease: (e, gestureState) => {...}`\r\n     *  - `onPanResponderMove: (e, gestureState) => {...}`\r\n     *  - `onPanResponderTerminate: (e, gestureState) => {...}`\r\n     *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`\r\n     *  - `onShouldBlockNativeResponder: (e, gestureState) => {...}`\r\n     *\r\n     *  In general, for events that have capture equivalents, we update the\r\n     *  gestureState once in the capture phase and can use it in the bubble phase\r\n     *  as well.\r\n     *\r\n     *  Be careful with onStartShould* callbacks. They only reflect updated\r\n     *  `gestureState` for start/end events that bubble/capture to the Node.\r\n     *  Once the node is the responder, you can rely on every start/end event\r\n     *  being processed by the gesture and `gestureState` being updated\r\n     *  accordingly. (numberActiveTouches) may not be totally accurate unless you\r\n     *  are the responder.\r\n     */\n    create: function create(config) {\n      var interactionState = {\n        handle: null\n      };\n      var gestureState = {\n        // Useful for debugging\n        stateID: Math.random()\n      };\n      PanResponder._initializeGestureState(gestureState);\n      var panHandlers = {\n        onStartShouldSetResponder: function onStartShouldSetResponder(e) {\n          return config.onStartShouldSetPanResponder === undefined ? false : config.onStartShouldSetPanResponder(e, gestureState);\n        },\n        onMoveShouldSetResponder: function onMoveShouldSetResponder(e) {\n          return config.onMoveShouldSetPanResponder === undefined ? false : config.onMoveShouldSetPanResponder(e, gestureState);\n        },\n        onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(e) {\n          // TODO: Actually, we should reinitialize the state any time\n          // touches.length increases from 0 active to > 0 active.\n          if (e.nativeEvent.touches.length === 1) {\n            PanResponder._initializeGestureState(gestureState);\n          }\n          gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\n          return config.onStartShouldSetPanResponderCapture !== undefined ? config.onStartShouldSetPanResponderCapture(e, gestureState) : false;\n        },\n        onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(e) {\n          var touchHistory = e.touchHistory; // Responder system incorrectly dispatches should* to current responder\n          // Filter out any touch moves past the first one - we would have\n          // already processed multi-touch geometry during the first event.\n\n          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n            return false;\n          }\n          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n          return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(e, gestureState) : false;\n        },\n        onResponderGrant: function onResponderGrant(e) {\n          if (!interactionState.handle) {\n            interactionState.handle = InteractionManager.createInteractionHandle();\n          }\n          gestureState.x0 = currentCentroidX(e.touchHistory);\n          gestureState.y0 = currentCentroidY(e.touchHistory);\n          gestureState.dx = 0;\n          gestureState.dy = 0;\n          if (config.onPanResponderGrant) {\n            config.onPanResponderGrant(e, gestureState);\n          } // TODO: t7467124 investigate if this can be removed\n\n          return config.onShouldBlockNativeResponder === undefined ? true : config.onShouldBlockNativeResponder();\n        },\n        onResponderReject: function onResponderReject(e) {\n          clearInteractionHandle(interactionState, config.onPanResponderReject, e, gestureState);\n        },\n        onResponderRelease: function onResponderRelease(e) {\n          clearInteractionHandle(interactionState, config.onPanResponderRelease, e, gestureState);\n          PanResponder._initializeGestureState(gestureState);\n        },\n        onResponderStart: function onResponderStart(e) {\n          var touchHistory = e.touchHistory;\n          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n          if (config.onPanResponderStart) {\n            config.onPanResponderStart(e, gestureState);\n          }\n        },\n        onResponderMove: function onResponderMove(e) {\n          var touchHistory = e.touchHistory; // Guard against the dispatch of two touch moves when there are two\n          // simultaneously changed touches.\n\n          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n            return;\n          } // Filter out any touch moves past the first one - we would have\n          // already processed multi-touch geometry during the first event.\n\n          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n          if (config.onPanResponderMove) {\n            config.onPanResponderMove(e, gestureState);\n          }\n        },\n        onResponderEnd: function onResponderEnd(e) {\n          var touchHistory = e.touchHistory;\n          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n          clearInteractionHandle(interactionState, config.onPanResponderEnd, e, gestureState);\n        },\n        onResponderTerminate: function onResponderTerminate(e) {\n          clearInteractionHandle(interactionState, config.onPanResponderTerminate, e, gestureState);\n          PanResponder._initializeGestureState(gestureState);\n        },\n        onResponderTerminationRequest: function onResponderTerminationRequest(e) {\n          return config.onPanResponderTerminationRequest === undefined ? true : config.onPanResponderTerminationRequest(e, gestureState);\n        }\n      };\n      return {\n        panHandlers: panHandlers,\n        getInteractionHandle: function getInteractionHandle() {\n          return interactionState.handle;\n        }\n      };\n    }\n  };\n  function clearInteractionHandle(interactionState, callback, event, gestureState) {\n    if (interactionState.handle) {\n      InteractionManager.clearInteractionHandle(interactionState.handle);\n      interactionState.handle = null;\n    }\n    if (callback) {\n      callback(event, gestureState);\n    }\n  }\n\n  /**\n   * Copyright (c) 2015-present, Nicolas Gallagher.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */\n\n  /**\n  * Updated by Javier Marquez - 2018\n  */\n  var emptyArray = [];\n  var emptyFunction = function emptyFunction() {};\n  var getRect = function getRect(node) {\n    if (node) {\n      var isElement = node.nodeType === 1\n      /* Node.ELEMENT_NODE */;\n\n      if (isElement && typeof node.getBoundingClientRect === 'function') {\n        return node.getBoundingClientRect();\n      }\n    }\n  }; // Mobile Safari re-uses touch objects, so we copy the properties we want and normalize the identifier\n\n  var normalizeTouches = function normalizeTouches(touches) {\n    if (!touches) {\n      return emptyArray;\n    }\n    return Array.prototype.slice.call(touches).map(function (touch) {\n      var identifier = touch.identifier > 20 ? touch.identifier % 20 : touch.identifier;\n      var rect;\n      return {\n        _normalized: true,\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n        force: touch.force,\n        get locationX() {\n          rect = rect || getRect(touch.target);\n          return rect && touch.pageX - rect.left || undefined;\n        },\n        get locationY() {\n          rect = rect || getRect(touch.target);\n          return rect && touch.pageY - rect.top || undefined;\n        },\n        identifier: identifier,\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        radiusX: touch.radiusX,\n        radiusY: touch.radiusY,\n        rotationAngle: touch.rotationAngle,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        target: touch.target,\n        // normalize the timestamp\n        // https://stackoverflow.com/questions/26177087/ios-8-mobile-safari-wrong-timestamp-on-touch-events\n        timestamp: Date.now()\n      };\n    });\n  };\n  function normalizeTouchEvent(nativeEvent) {\n    var changedTouches = normalizeTouches(nativeEvent.changedTouches);\n    var touches = normalizeTouches(nativeEvent.touches);\n    var preventDefault = typeof nativeEvent.preventDefault === 'function' ? nativeEvent.preventDefault.bind(nativeEvent) : emptyFunction;\n    var stopImmediatePropagation = typeof nativeEvent.stopImmediatePropagation === 'function' ? nativeEvent.stopImmediatePropagation.bind(nativeEvent) : emptyFunction;\n    var stopPropagation = typeof nativeEvent.stopPropagation === 'function' ? nativeEvent.stopPropagation.bind(nativeEvent) : emptyFunction;\n    var event = {\n      _normalized: true,\n      bubbles: nativeEvent.bubbles,\n      cancelable: nativeEvent.cancelable,\n      changedTouches: changedTouches,\n      defaultPrevented: nativeEvent.defaultPrevented,\n      identifier: undefined,\n      locationX: undefined,\n      locationY: undefined,\n      pageX: nativeEvent.pageX,\n      pageY: nativeEvent.pageY,\n      preventDefault: preventDefault,\n      stopImmediatePropagation: stopImmediatePropagation,\n      stopPropagation: stopPropagation,\n      target: nativeEvent.target,\n      // normalize the timestamp\n      // https://stackoverflow.com/questions/26177087/ios-8-mobile-safari-wrong-timestamp-on-touch-events\n      timestamp: Date.now(),\n      touches: touches,\n      type: nativeEvent.type,\n      which: nativeEvent.which\n    };\n    if (changedTouches[0]) {\n      event.identifier = changedTouches[0].identifier;\n      event.pageX = changedTouches[0].pageX;\n      event.pageY = changedTouches[0].pageY;\n      event.locationX = changedTouches[0].locationX;\n      event.locationY = changedTouches[0].locationY;\n    }\n    return event;\n  }\n  function normalizeMouseEvent(nativeEvent) {\n    var rect;\n    var touches = [{\n      _normalized: true,\n      clientX: nativeEvent.clientX,\n      clientY: nativeEvent.clientY,\n      force: nativeEvent.force,\n      identifier: 0,\n      get locationX() {\n        rect = rect || getRect(nativeEvent.target);\n        return rect && nativeEvent.pageX - rect.left || undefined;\n      },\n      get locationY() {\n        rect = rect || getRect(nativeEvent.target);\n        return rect && nativeEvent.pageY - rect.top || undefined;\n      },\n      pageX: nativeEvent.pageX,\n      pageY: nativeEvent.pageY,\n      screenX: nativeEvent.screenX,\n      screenY: nativeEvent.screenY,\n      target: nativeEvent.target,\n      timestamp: Date.now()\n    }];\n    var preventDefault = typeof nativeEvent.preventDefault === 'function' ? nativeEvent.preventDefault.bind(nativeEvent) : emptyFunction;\n    var stopImmediatePropagation = typeof nativeEvent.stopImmediatePropagation === 'function' ? nativeEvent.stopImmediatePropagation.bind(nativeEvent) : emptyFunction;\n    var stopPropagation = typeof nativeEvent.stopPropagation === 'function' ? nativeEvent.stopPropagation.bind(nativeEvent) : emptyFunction;\n    return {\n      _normalized: true,\n      bubbles: nativeEvent.bubbles,\n      cancelable: nativeEvent.cancelable,\n      changedTouches: touches,\n      defaultPrevented: nativeEvent.defaultPrevented,\n      identifier: touches[0].identifier,\n      locationX: touches[0].locationX,\n      locationY: touches[0].locationY,\n      pageX: nativeEvent.pageX,\n      pageY: nativeEvent.pageY,\n      preventDefault: preventDefault,\n      stopImmediatePropagation: stopImmediatePropagation,\n      stopPropagation: stopPropagation,\n      target: nativeEvent.target,\n      timestamp: touches[0].timestamp,\n      touches: nativeEvent.type === 'mouseup' ? emptyArray : touches,\n      type: nativeEvent.type,\n      which: nativeEvent.which\n    };\n  } // TODO: how to best handle keyboard events?\n\n  function normalizeNativeEvent(nativeEvent) {\n    if (!nativeEvent || nativeEvent._normalized) {\n      return nativeEvent;\n    }\n    var eventType = nativeEvent.type || '';\n    var mouse = eventType.indexOf('mouse') >= 0;\n    if (mouse) {\n      return normalizeMouseEvent(nativeEvent);\n    } else {\n      return normalizeTouchEvent(nativeEvent);\n    }\n  }\n\n  // based on https://github.com/facebook/react/pull/4303/files\n  var ResponderEventPlugin = ReactDOMUnstableNativeDependencies__default.ResponderEventPlugin,\n    ResponderTouchHistoryStore = ReactDOMUnstableNativeDependencies__default.ResponderTouchHistoryStore; // On older versions of React (< 16.4) we have to inject the dependencies in\n  // order for the plugin to work properly in the browser. This version still\n  // uses `top*` strings to identify the internal event names.\n  // https://github.com/facebook/react/pull/12629\n\n  var types = ResponderEventPlugin.eventTypes;\n  if (!types.responderMove.dependencies) {\n    var endDependencies = ['topTouchCancel', 'topTouchEnd', 'topMouseUp'];\n    var moveDependencies = ['topTouchMove', 'topMouseMove'];\n    var startDependencies = ['topTouchStart', 'topMouseDown'];\n    /**\n     * Setup ResponderEventPlugin dependencies\n     */\n\n    types.responderMove.dependencies = moveDependencies;\n    types.responderEnd.dependencies = endDependencies;\n    types.responderStart.dependencies = startDependencies;\n    types.responderRelease.dependencies = endDependencies;\n    types.responderTerminationRequest.dependencies = [];\n    types.responderGrant.dependencies = [];\n    types.responderReject.dependencies = [];\n    types.responderTerminate.dependencies = [];\n    types.moveShouldSetResponder.dependencies = moveDependencies;\n    types.selectionChangeShouldSetResponder.dependencies = ['topSelectionChange'];\n    types.scrollShouldSetResponder.dependencies = ['topScroll'];\n    types.startShouldSetResponder.dependencies = startDependencies;\n  }\n  var lastActiveTouchTimestamp = null;\n  var originalExtractEvents = ResponderEventPlugin.extractEvents;\n  ResponderEventPlugin.extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var hasActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches > 0;\n    var eventType = nativeEvent.type;\n    var shouldSkipMouseAfterTouch = false;\n    if (eventType.indexOf('touch') > -1) {\n      lastActiveTouchTimestamp = Date.now();\n    } else if (lastActiveTouchTimestamp && eventType.indexOf('mouse') > -1) {\n      var now = Date.now();\n      shouldSkipMouseAfterTouch = now - lastActiveTouchTimestamp < 250;\n    }\n    if (\n    // Filter out mousemove and mouseup events when a touch hasn't started yet\n    (eventType === 'mousemove' || eventType === 'mouseup') && !hasActiveTouches ||\n    // Filter out events from wheel/middle and right click.\n    nativeEvent.button === 1 || nativeEvent.button === 2 ||\n    // Filter out mouse events that browsers dispatch immediately after touch events end\n    // Prevents the REP from calling handlers twice for touch interactions.\n    // See #802 and #932.\n    shouldSkipMouseAfterTouch) {\n      return;\n    }\n    var normalizedEvent = normalizeNativeEvent(nativeEvent);\n    return originalExtractEvents.call(ResponderEventPlugin, topLevelType, targetInst, normalizedEvent, nativeEventTarget);\n  };\n  ReactDOMUnstableNativeDependencies.injectEventPluginsByName({\n    ResponderEventPlugin: ResponderEventPlugin\n  });\n  return PanResponder;\n});","map":{"version":3,"names":["global","factory","exports","module","require","define","amd","PanResponder","UnstableDependencies","ReactDOMUnstableNativeDependencies","ReactDOMUnstableNativeDependencies__default","_requestIdleCallback","cb","options","setTimeout","start","Date","now","didTimeout","timeRemaining","Math","max","_cancelIdleCallback","id","clearTimeout","isSupported","window","requestIdleCallback","cancelIdleCallback","InteractionManager","Events","interactionStart","interactionComplete","runAfterInteractions","task","handle","promise","Promise","resolve","then","bind","done","cancel","createInteractionHandle","clearInteractionHandle","console","warn","addListener","TouchHistoryMath","centroidDimension","touchHistory","touchesChangedAfter","isXAxis","ofCurrent","touchBank","total","count","oneTouchData","numberActiveTouches","indexOfSingleActiveTouch","touchActive","currentTimeStamp","currentPageX","currentPageY","previousPageX","previousPageY","i","length","touchTrack","undefined","toAdd","noCentroid","currentCentroidXOfTouchesChangedAfter","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","currentCentroidX","currentCentroidY","_initializeGestureState","gestureState","moveX","moveY","x0","y0","dx","dy","vx","vy","_accountsForMovesUpTo","_updateGestureStateOnMove","movedAfter","prevX","x","prevY","y","nextDX","nextDY","dt","mostRecentTimeStamp","create","config","interactionState","stateID","random","panHandlers","onStartShouldSetResponder","e","onStartShouldSetPanResponder","onMoveShouldSetResponder","onMoveShouldSetPanResponder","onStartShouldSetResponderCapture","nativeEvent","touches","onStartShouldSetPanResponderCapture","onMoveShouldSetResponderCapture","onMoveShouldSetPanResponderCapture","onResponderGrant","onPanResponderGrant","onShouldBlockNativeResponder","onResponderReject","onPanResponderReject","onResponderRelease","onPanResponderRelease","onResponderStart","onPanResponderStart","onResponderMove","onPanResponderMove","onResponderEnd","onPanResponderEnd","onResponderTerminate","onPanResponderTerminate","onResponderTerminationRequest","onPanResponderTerminationRequest","getInteractionHandle","callback","event","emptyArray","emptyFunction","getRect","node","isElement","nodeType","getBoundingClientRect","normalizeTouches","Array","prototype","slice","call","map","touch","identifier","rect","_normalized","clientX","clientY","force","locationX","target","pageX","left","locationY","pageY","top","radiusX","radiusY","rotationAngle","screenX","screenY","timestamp","normalizeTouchEvent","changedTouches","preventDefault","stopImmediatePropagation","stopPropagation","bubbles","cancelable","defaultPrevented","type","which","normalizeMouseEvent","normalizeNativeEvent","eventType","mouse","indexOf","ResponderEventPlugin","ResponderTouchHistoryStore","types","eventTypes","responderMove","dependencies","endDependencies","moveDependencies","startDependencies","responderEnd","responderStart","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","moveShouldSetResponder","selectionChangeShouldSetResponder","scrollShouldSetResponder","startShouldSetResponder","lastActiveTouchTimestamp","originalExtractEvents","extractEvents","topLevelType","targetInst","nativeEventTarget","hasActiveTouches","shouldSkipMouseAfterTouch","button","normalizedEvent","injectEventPluginsByName"],"sources":["/Users/sethstephens/Desktop/fureverv4/furever/Client/node_modules/react-panresponder-web/dist/panresponder.js"],"sourcesContent":["/*!\n * react-panresponder-web v1.0.0\n * (c) 2018-present Javier Marquez\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react-dom/unstable-native-dependencies')) :\n  typeof define === 'function' && define.amd ? define(['react-dom/unstable-native-dependencies'], factory) :\n  (global.PanResponder = factory(global.UnstableDependencies));\n}(this, (function (ReactDOMUnstableNativeDependencies) { 'use strict';\n\n  var ReactDOMUnstableNativeDependencies__default = 'default' in ReactDOMUnstableNativeDependencies ? ReactDOMUnstableNativeDependencies['default'] : ReactDOMUnstableNativeDependencies;\n\n  /**\r\n   * Copyright (c) 2015-present, Nicolas Gallagher.\r\n   *\r\n   * This source code is licensed under the MIT license found in the\r\n   * LICENSE file in the root directory of this source tree.\r\n   *\r\n   */\n  var _requestIdleCallback = function _requestIdleCallback(cb, options) {\n    return setTimeout(function () {\n      var start = Date.now();\n      cb({\n        didTimeout: false,\n        timeRemaining: function timeRemaining() {\n          return Math.max(0, 50 - (Date.now() - start));\n        }\n      });\n    }, 1);\n  };\n\n  var _cancelIdleCallback = function _cancelIdleCallback(id) {\n    clearTimeout(id);\n  };\n\n  var isSupported = typeof window.requestIdleCallback !== 'undefined';\n  var requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;\n  var cancelIdleCallback = isSupported ? window.cancelIdleCallback : _cancelIdleCallback;\n\n  /**\r\n   * Copyright (c) 2016-present, Nicolas Gallagher.\r\n   * Copyright (c) 2015-present, Facebook, Inc.\r\n   *\r\n   * This source code is licensed under the MIT license found in the\r\n   * LICENSE file in the root directory of this source tree.\r\n   *\r\n   */\n  var InteractionManager = {\n    Events: {\n      interactionStart: 'interactionStart',\n      interactionComplete: 'interactionComplete'\n    },\n\n    /**\r\n     * Schedule a function to run after all interactions have completed.\r\n     */\n    runAfterInteractions: function runAfterInteractions(task) {\n      var handle;\n      var promise = new Promise(function (resolve) {\n        handle = requestIdleCallback(function () {\n          if (task) {\n            resolve(task());\n          }\n        });\n      });\n      return {\n        then: promise.then.bind(promise),\n        done: promise.then.bind(promise),\n        cancel: function cancel() {\n          cancelIdleCallback(handle);\n        }\n      };\n    },\n\n    /**\r\n     * Notify manager that an interaction has started.\r\n     */\n    createInteractionHandle: function createInteractionHandle() {\n      return 1;\n    },\n\n    /**\r\n     * Notify manager that an interaction has completed.\r\n     */\n    clearInteractionHandle: function clearInteractionHandle(handle) {\n      !handle && console.warn('Must provide a handle to clear.');\n    },\n    addListener: function addListener() {}\n  };\n\n  var TouchHistoryMath = {\n    /**\r\n     * This code is optimized and not intended to look beautiful. This allows\r\n     * computing of touch centroids that have moved after `touchesChangedAfter`\r\n     * timeStamp. You can compute the current centroid involving all touches\r\n     * moves after `touchesChangedAfter`, or you can compute the previous\r\n     * centroid of all touches that were moved after `touchesChangedAfter`.\r\n     *\r\n     * @param {TouchHistoryMath} touchHistory Standard Responder touch track\r\n     * data.\r\n     * @param {number} touchesChangedAfter timeStamp after which moved touches\r\n     * are considered \"actively moving\" - not just \"active\".\r\n     * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.\r\n     * @param {boolean} ofCurrent Compute current centroid for actively moving\r\n     * touches vs. previous centroid of now actively moving touches.\r\n     * @return {number} value of centroid in specified dimension.\r\n     */\n    centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {\n      var touchBank = touchHistory.touchBank;\n      var total = 0;\n      var count = 0;\n      var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;\n\n      if (oneTouchData !== null) {\n        if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {\n          total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;\n          count = 1;\n        }\n      } else {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrack = touchBank[i];\n\n          if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {\n            var toAdd = void 0; // Yuck, program temporarily in invalid state.\n\n            if (ofCurrent && isXAxis) {\n              toAdd = touchTrack.currentPageX;\n            } else if (ofCurrent && !isXAxis) {\n              toAdd = touchTrack.currentPageY;\n            } else if (!ofCurrent && isXAxis) {\n              toAdd = touchTrack.previousPageX;\n            } else {\n              toAdd = touchTrack.previousPageY;\n            }\n\n            total += toAdd;\n            count++;\n          }\n        }\n      }\n\n      return count > 0 ? total / count : TouchHistoryMath.noCentroid;\n    },\n    currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {\n      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis\n      true);\n    },\n    currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {\n      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis\n      true);\n    },\n    previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {\n      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis\n      false);\n    },\n    previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {\n      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis\n      false);\n    },\n    currentCentroidX: function currentCentroidX(touchHistory) {\n      return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter\n      true, // isXAxis\n      true);\n    },\n    currentCentroidY: function currentCentroidY(touchHistory) {\n      return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter\n      false, // isXAxis\n      true);\n    },\n    noCentroid: -1\n  };\n\n  /**\r\n   * Copyright (c) 2013-present, Facebook, Inc.\r\n   *\r\n   * This source code is licensed under the MIT license found in the\r\n   * LICENSE file in the root directory of this source tree.\r\n   */\n  var currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;\n  var currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;\n  var previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;\n  var previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;\n  var currentCentroidX = TouchHistoryMath.currentCentroidX;\n  var currentCentroidY = TouchHistoryMath.currentCentroidY;\n  /**\r\n   * `PanResponder` reconciles several touches into a single gesture. It makes\r\n   * single-touch gestures resilient to extra touches, and can be used to\r\n   * recognize simple multi-touch gestures.\r\n   *\r\n   * By default, `PanResponder` holds an `InteractionManager` handle to block\r\n   * long-running JS events from interrupting active gestures.\r\n   *\r\n   * It provides a predictable wrapper of the responder handlers provided by the\r\n   * [gesture responder system](docs/gesture-responder-system.html).\r\n   * For each handler, it provides a new `gestureState` object alongside the\r\n   * native event object:\r\n   *\r\n   * ```\r\n   * onPanResponderMove: (event, gestureState) => {}\r\n   * ```\r\n   *\r\n   * A native event is a synthetic touch event with the following form:\r\n   *\r\n   *  - `nativeEvent`\r\n   *      + `changedTouches` - Array of all touch events that have changed since the last event\r\n   *      + `identifier` - The ID of the touch\r\n   *      + `locationX` - The X position of the touch, relative to the element\r\n   *      + `locationY` - The Y position of the touch, relative to the element\r\n   *      + `pageX` - The X position of the touch, relative to the root element\r\n   *      + `pageY` - The Y position of the touch, relative to the root element\r\n   *      + `target` - The node id of the element receiving the touch event\r\n   *      + `timestamp` - A time identifier for the touch, useful for velocity calculation\r\n   *      + `touches` - Array of all current touches on the screen\r\n   *\r\n   * A `gestureState` object has the following:\r\n   *\r\n   *  - `stateID` - ID of the gestureState- persisted as long as there at least\r\n   *     one touch on screen\r\n   *  - `moveX` - the latest screen coordinates of the recently-moved touch\r\n   *  - `moveY` - the latest screen coordinates of the recently-moved touch\r\n   *  - `x0` - the screen coordinates of the responder grant\r\n   *  - `y0` - the screen coordinates of the responder grant\r\n   *  - `dx` - accumulated distance of the gesture since the touch started\r\n   *  - `dy` - accumulated distance of the gesture since the touch started\r\n   *  - `vx` - current velocity of the gesture\r\n   *  - `vy` - current velocity of the gesture\r\n   *  - `numberActiveTouches` - Number of touches currently on screen\r\n   *\r\n   * ### Basic Usage\r\n   *\r\n   * ```\r\n   *   componentWillMount: function() {\r\n   *     this._panResponder = PanResponder.create({\r\n   *       // Ask to be the responder:\r\n   *       onStartShouldSetPanResponder: (evt, gestureState) => true,\r\n   *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\r\n   *       onMoveShouldSetPanResponder: (evt, gestureState) => true,\r\n   *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\r\n   *\r\n   *       onPanResponderGrant: (evt, gestureState) => {\r\n   *         // The gesture has started. Show visual feedback so the user knows\r\n   *         // what is happening!\r\n   *\r\n   *         // gestureState.d{x,y} will be set to zero now\r\n   *       },\r\n   *       onPanResponderMove: (evt, gestureState) => {\r\n   *         // The most recent move distance is gestureState.move{X,Y}\r\n   *\r\n   *         // The accumulated gesture distance since becoming responder is\r\n   *         // gestureState.d{x,y}\r\n   *       },\r\n   *       onPanResponderTerminationRequest: (evt, gestureState) => true,\r\n   *       onPanResponderRelease: (evt, gestureState) => {\r\n   *         // The user has released all touches while this view is the\r\n   *         // responder. This typically means a gesture has succeeded\r\n   *       },\r\n   *       onPanResponderTerminate: (evt, gestureState) => {\r\n   *         // Another component has become the responder, so this gesture\r\n   *         // should be cancelled\r\n   *       },\r\n   *       onShouldBlockNativeResponder: (evt, gestureState) => {\r\n   *         // Returns whether this component should block native components from becoming the JS\r\n   *         // responder. Returns true by default. Is currently only supported on android.\r\n   *         return true;\r\n   *       },\r\n   *     });\r\n   *   },\r\n   *\r\n   *   render: function() {\r\n   *     return (\r\n   *       <View {...this._panResponder.panHandlers} />\r\n   *     );\r\n   *   },\r\n   *\r\n   * ```\r\n   *\r\n   * ### Working Example\r\n   *\r\n   * To see it in action, try the\r\n   * [PanResponder example in RNTester](https://github.com/facebook/react-native/blob/master/RNTester/js/PanResponderExample.js)\r\n   */\n\n  var PanResponder = {\n    /**\r\n     *\r\n     * A graphical explanation of the touch data flow:\r\n     *\r\n     * +----------------------------+             +--------------------------------+\r\n     * | ResponderTouchHistoryStore |             |TouchHistoryMath                |\r\n     * +----------------------------+             +----------+---------------------+\r\n     * |Global store of touchHistory|             |Allocation-less math util       |\r\n     * |including activeness, start |             |on touch history (centroids     |\r\n     * |position, prev/cur position.|             |and multitouch movement etc)    |\r\n     * |                            |             |                                |\r\n     * +----^-----------------------+             +----^---------------------------+\r\n     *      |                                          |\r\n     *      | (records relevant history                |\r\n     *      |  of touches relevant for                 |\r\n     *      |  implementing higher level               |\r\n     *      |  gestures)                               |\r\n     *      |                                          |\r\n     * +----+-----------------------+             +----|---------------------------+\r\n     * | ResponderEventPlugin       |             |    |   Your App/Component      |\r\n     * +----------------------------+             +----|---------------------------+\r\n     * |Negotiates which view gets  | Low level   |    |             High level    |\r\n     * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |\r\n     * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |\r\n     * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|\r\n     * +----------------------------+ attached to |  |         |     distance and  |\r\n     *                                 each event |  +---------+     velocity.     |\r\n     *                                            |                                |\r\n     *                                            |                                |\r\n     *                                            +--------------------------------+\r\n     *\r\n     *\r\n     *\r\n     * Gesture that calculates cumulative movement over time in a way that just\r\n     * \"does the right thing\" for multiple touches. The \"right thing\" is very\r\n     * nuanced. When moving two touches in opposite directions, the cumulative\r\n     * distance is zero in each dimension. When two touches move in parallel five\r\n     * pixels in the same direction, the cumulative distance is five, not ten. If\r\n     * two touches start, one moves five in a direction, then stops and the other\r\n     * touch moves fives in the same direction, the cumulative distance is ten.\r\n     *\r\n     * This logic requires a kind of processing of time \"clusters\" of touch events\r\n     * so that two touch moves that essentially occur in parallel but move every\r\n     * other frame respectively, are considered part of the same movement.\r\n     *\r\n     * Explanation of some of the non-obvious fields:\r\n     *\r\n     * - moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is\r\n     *   invalid. If a move event has been observed, `(moveX, moveY)` is the\r\n     *   centroid of the most recently moved \"cluster\" of active touches.\r\n     *   (Currently all move have the same timeStamp, but later we should add some\r\n     *   threshold for what is considered to be \"moving\"). If a palm is\r\n     *   accidentally counted as a touch, but a finger is moving greatly, the palm\r\n     *   will move slightly, but we only want to count the single moving touch.\r\n     * - x0/y0: Centroid location (non-cumulative) at the time of becoming\r\n     *   responder.\r\n     * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch\r\n     *   distance. Accounts for touch moves that are clustered together in time,\r\n     *   moving the same direction. Only valid when currently responder (otherwise,\r\n     *   it only represents the drag distance below the threshold).\r\n     * - vx/vy: Velocity.\r\n     */\n    _initializeGestureState: function _initializeGestureState(gestureState) {\n      gestureState.moveX = 0;\n      gestureState.moveY = 0;\n      gestureState.x0 = 0;\n      gestureState.y0 = 0;\n      gestureState.dx = 0;\n      gestureState.dy = 0;\n      gestureState.vx = 0;\n      gestureState.vy = 0;\n      gestureState.numberActiveTouches = 0; // All `gestureState` accounts for timeStamps up until:\n\n      gestureState._accountsForMovesUpTo = 0;\n    },\n\n    /**\r\n     * This is nuanced and is necessary. It is incorrect to continuously take all\r\n     * active *and* recently moved touches, find the centroid, and track how that\r\n     * result changes over time. Instead, we must take all recently moved\r\n     * touches, and calculate how the centroid has changed just for those\r\n     * recently moved touches, and append that change to an accumulator. This is\r\n     * to (at least) handle the case where the user is moving three fingers, and\r\n     * then one of the fingers stops but the other two continue.\r\n     *\r\n     * This is very different than taking all of the recently moved touches and\r\n     * storing their centroid as `dx/dy`. For correctness, we must *accumulate\r\n     * changes* in the centroid of recently moved touches.\r\n     *\r\n     * There is also some nuance with how we handle multiple moved touches in a\r\n     * single event. With the way `ReactNativeEventEmitter` dispatches touches as\r\n     * individual events, multiple touches generate two 'move' events, each of\r\n     * them triggering `onResponderMove`. But with the way `PanResponder` works,\r\n     * all of the gesture inference is performed on the first dispatch, since it\r\n     * looks at all of the touches (even the ones for which there hasn't been a\r\n     * native dispatch yet). Therefore, `PanResponder` does not call\r\n     * `onResponderMove` passed the first dispatch. This diverges from the\r\n     * typical responder callback pattern (without using `PanResponder`), but\r\n     * avoids more dispatches than necessary.\r\n     */\n    _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {\n      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n      gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);\n      gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);\n      var movedAfter = gestureState._accountsForMovesUpTo;\n      var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n      var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n      var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n      var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n      var nextDX = gestureState.dx + (x - prevX);\n      var nextDY = gestureState.dy + (y - prevY); // TODO: This must be filtered intelligently.\n\n      var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;\n      gestureState.vx = (nextDX - gestureState.dx) / dt;\n      gestureState.vy = (nextDY - gestureState.dy) / dt;\n      gestureState.dx = nextDX;\n      gestureState.dy = nextDY;\n      gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n    },\n\n    /**\r\n     * @param {object} config Enhanced versions of all of the responder callbacks\r\n     * that provide not only the typical `ResponderSyntheticEvent`, but also the\r\n     * `PanResponder` gesture state.  Simply replace the word `Responder` with\r\n     * `PanResponder` in each of the typical `onResponder*` callbacks. For\r\n     * example, the `config` object would look like:\r\n     *\r\n     *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`\r\n     *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`\r\n     *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`\r\n     *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`\r\n     *  - `onPanResponderReject: (e, gestureState) => {...}`\r\n     *  - `onPanResponderGrant: (e, gestureState) => {...}`\r\n     *  - `onPanResponderStart: (e, gestureState) => {...}`\r\n     *  - `onPanResponderEnd: (e, gestureState) => {...}`\r\n     *  - `onPanResponderRelease: (e, gestureState) => {...}`\r\n     *  - `onPanResponderMove: (e, gestureState) => {...}`\r\n     *  - `onPanResponderTerminate: (e, gestureState) => {...}`\r\n     *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`\r\n     *  - `onShouldBlockNativeResponder: (e, gestureState) => {...}`\r\n     *\r\n     *  In general, for events that have capture equivalents, we update the\r\n     *  gestureState once in the capture phase and can use it in the bubble phase\r\n     *  as well.\r\n     *\r\n     *  Be careful with onStartShould* callbacks. They only reflect updated\r\n     *  `gestureState` for start/end events that bubble/capture to the Node.\r\n     *  Once the node is the responder, you can rely on every start/end event\r\n     *  being processed by the gesture and `gestureState` being updated\r\n     *  accordingly. (numberActiveTouches) may not be totally accurate unless you\r\n     *  are the responder.\r\n     */\n    create: function create(config) {\n      var interactionState = {\n        handle: null\n      };\n      var gestureState = {\n        // Useful for debugging\n        stateID: Math.random()\n      };\n\n      PanResponder._initializeGestureState(gestureState);\n\n      var panHandlers = {\n        onStartShouldSetResponder: function onStartShouldSetResponder(e) {\n          return config.onStartShouldSetPanResponder === undefined ? false : config.onStartShouldSetPanResponder(e, gestureState);\n        },\n        onMoveShouldSetResponder: function onMoveShouldSetResponder(e) {\n          return config.onMoveShouldSetPanResponder === undefined ? false : config.onMoveShouldSetPanResponder(e, gestureState);\n        },\n        onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(e) {\n          // TODO: Actually, we should reinitialize the state any time\n          // touches.length increases from 0 active to > 0 active.\n          if (e.nativeEvent.touches.length === 1) {\n            PanResponder._initializeGestureState(gestureState);\n          }\n\n          gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\n          return config.onStartShouldSetPanResponderCapture !== undefined ? config.onStartShouldSetPanResponderCapture(e, gestureState) : false;\n        },\n        onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(e) {\n          var touchHistory = e.touchHistory; // Responder system incorrectly dispatches should* to current responder\n          // Filter out any touch moves past the first one - we would have\n          // already processed multi-touch geometry during the first event.\n\n          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n            return false;\n          }\n\n          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n\n          return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(e, gestureState) : false;\n        },\n        onResponderGrant: function onResponderGrant(e) {\n          if (!interactionState.handle) {\n            interactionState.handle = InteractionManager.createInteractionHandle();\n          }\n\n          gestureState.x0 = currentCentroidX(e.touchHistory);\n          gestureState.y0 = currentCentroidY(e.touchHistory);\n          gestureState.dx = 0;\n          gestureState.dy = 0;\n\n          if (config.onPanResponderGrant) {\n            config.onPanResponderGrant(e, gestureState);\n          } // TODO: t7467124 investigate if this can be removed\n\n\n          return config.onShouldBlockNativeResponder === undefined ? true : config.onShouldBlockNativeResponder();\n        },\n        onResponderReject: function onResponderReject(e) {\n          clearInteractionHandle(interactionState, config.onPanResponderReject, e, gestureState);\n        },\n        onResponderRelease: function onResponderRelease(e) {\n          clearInteractionHandle(interactionState, config.onPanResponderRelease, e, gestureState);\n\n          PanResponder._initializeGestureState(gestureState);\n        },\n        onResponderStart: function onResponderStart(e) {\n          var touchHistory = e.touchHistory;\n          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n\n          if (config.onPanResponderStart) {\n            config.onPanResponderStart(e, gestureState);\n          }\n        },\n        onResponderMove: function onResponderMove(e) {\n          var touchHistory = e.touchHistory; // Guard against the dispatch of two touch moves when there are two\n          // simultaneously changed touches.\n\n          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n            return;\n          } // Filter out any touch moves past the first one - we would have\n          // already processed multi-touch geometry during the first event.\n\n\n          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n\n          if (config.onPanResponderMove) {\n            config.onPanResponderMove(e, gestureState);\n          }\n        },\n        onResponderEnd: function onResponderEnd(e) {\n          var touchHistory = e.touchHistory;\n          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n          clearInteractionHandle(interactionState, config.onPanResponderEnd, e, gestureState);\n        },\n        onResponderTerminate: function onResponderTerminate(e) {\n          clearInteractionHandle(interactionState, config.onPanResponderTerminate, e, gestureState);\n\n          PanResponder._initializeGestureState(gestureState);\n        },\n        onResponderTerminationRequest: function onResponderTerminationRequest(e) {\n          return config.onPanResponderTerminationRequest === undefined ? true : config.onPanResponderTerminationRequest(e, gestureState);\n        }\n      };\n      return {\n        panHandlers: panHandlers,\n        getInteractionHandle: function getInteractionHandle() {\n          return interactionState.handle;\n        }\n      };\n    }\n  };\n\n  function clearInteractionHandle(interactionState, callback, event, gestureState) {\n    if (interactionState.handle) {\n      InteractionManager.clearInteractionHandle(interactionState.handle);\n      interactionState.handle = null;\n    }\n\n    if (callback) {\n      callback(event, gestureState);\n    }\n  }\n\n  /**\n   * Copyright (c) 2015-present, Nicolas Gallagher.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */\n\n  /**\n  * Updated by Javier Marquez - 2018\n  */\n  var emptyArray = [];\n\n  var emptyFunction = function emptyFunction() {};\n\n  var getRect = function getRect(node) {\n    if (node) {\n      var isElement = node.nodeType === 1\n      /* Node.ELEMENT_NODE */\n      ;\n\n      if (isElement && typeof node.getBoundingClientRect === 'function') {\n        return node.getBoundingClientRect();\n      }\n    }\n  }; // Mobile Safari re-uses touch objects, so we copy the properties we want and normalize the identifier\n\n\n  var normalizeTouches = function normalizeTouches(touches) {\n    if (!touches) {\n      return emptyArray;\n    }\n\n    return Array.prototype.slice.call(touches).map(function (touch) {\n      var identifier = touch.identifier > 20 ? touch.identifier % 20 : touch.identifier;\n      var rect;\n      return {\n        _normalized: true,\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n        force: touch.force,\n\n        get locationX() {\n          rect = rect || getRect(touch.target);\n          return rect && touch.pageX - rect.left || undefined;\n        },\n\n        get locationY() {\n          rect = rect || getRect(touch.target);\n          return rect && touch.pageY - rect.top || undefined;\n        },\n\n        identifier: identifier,\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        radiusX: touch.radiusX,\n        radiusY: touch.radiusY,\n        rotationAngle: touch.rotationAngle,\n        screenX: touch.screenX,\n        screenY: touch.screenY,\n        target: touch.target,\n        // normalize the timestamp\n        // https://stackoverflow.com/questions/26177087/ios-8-mobile-safari-wrong-timestamp-on-touch-events\n        timestamp: Date.now()\n      };\n    });\n  };\n\n  function normalizeTouchEvent(nativeEvent) {\n    var changedTouches = normalizeTouches(nativeEvent.changedTouches);\n    var touches = normalizeTouches(nativeEvent.touches);\n    var preventDefault = typeof nativeEvent.preventDefault === 'function' ? nativeEvent.preventDefault.bind(nativeEvent) : emptyFunction;\n    var stopImmediatePropagation = typeof nativeEvent.stopImmediatePropagation === 'function' ? nativeEvent.stopImmediatePropagation.bind(nativeEvent) : emptyFunction;\n    var stopPropagation = typeof nativeEvent.stopPropagation === 'function' ? nativeEvent.stopPropagation.bind(nativeEvent) : emptyFunction;\n    var event = {\n      _normalized: true,\n      bubbles: nativeEvent.bubbles,\n      cancelable: nativeEvent.cancelable,\n      changedTouches: changedTouches,\n      defaultPrevented: nativeEvent.defaultPrevented,\n      identifier: undefined,\n      locationX: undefined,\n      locationY: undefined,\n      pageX: nativeEvent.pageX,\n      pageY: nativeEvent.pageY,\n      preventDefault: preventDefault,\n      stopImmediatePropagation: stopImmediatePropagation,\n      stopPropagation: stopPropagation,\n      target: nativeEvent.target,\n      // normalize the timestamp\n      // https://stackoverflow.com/questions/26177087/ios-8-mobile-safari-wrong-timestamp-on-touch-events\n      timestamp: Date.now(),\n      touches: touches,\n      type: nativeEvent.type,\n      which: nativeEvent.which\n    };\n\n    if (changedTouches[0]) {\n      event.identifier = changedTouches[0].identifier;\n      event.pageX = changedTouches[0].pageX;\n      event.pageY = changedTouches[0].pageY;\n      event.locationX = changedTouches[0].locationX;\n      event.locationY = changedTouches[0].locationY;\n    }\n\n    return event;\n  }\n\n  function normalizeMouseEvent(nativeEvent) {\n    var rect;\n    var touches = [{\n      _normalized: true,\n      clientX: nativeEvent.clientX,\n      clientY: nativeEvent.clientY,\n      force: nativeEvent.force,\n      identifier: 0,\n\n      get locationX() {\n        rect = rect || getRect(nativeEvent.target);\n        return rect && nativeEvent.pageX - rect.left || undefined;\n      },\n\n      get locationY() {\n        rect = rect || getRect(nativeEvent.target);\n        return rect && nativeEvent.pageY - rect.top || undefined;\n      },\n\n      pageX: nativeEvent.pageX,\n      pageY: nativeEvent.pageY,\n      screenX: nativeEvent.screenX,\n      screenY: nativeEvent.screenY,\n      target: nativeEvent.target,\n      timestamp: Date.now()\n    }];\n    var preventDefault = typeof nativeEvent.preventDefault === 'function' ? nativeEvent.preventDefault.bind(nativeEvent) : emptyFunction;\n    var stopImmediatePropagation = typeof nativeEvent.stopImmediatePropagation === 'function' ? nativeEvent.stopImmediatePropagation.bind(nativeEvent) : emptyFunction;\n    var stopPropagation = typeof nativeEvent.stopPropagation === 'function' ? nativeEvent.stopPropagation.bind(nativeEvent) : emptyFunction;\n    return {\n      _normalized: true,\n      bubbles: nativeEvent.bubbles,\n      cancelable: nativeEvent.cancelable,\n      changedTouches: touches,\n      defaultPrevented: nativeEvent.defaultPrevented,\n      identifier: touches[0].identifier,\n      locationX: touches[0].locationX,\n      locationY: touches[0].locationY,\n      pageX: nativeEvent.pageX,\n      pageY: nativeEvent.pageY,\n      preventDefault: preventDefault,\n      stopImmediatePropagation: stopImmediatePropagation,\n      stopPropagation: stopPropagation,\n      target: nativeEvent.target,\n      timestamp: touches[0].timestamp,\n      touches: nativeEvent.type === 'mouseup' ? emptyArray : touches,\n      type: nativeEvent.type,\n      which: nativeEvent.which\n    };\n  } // TODO: how to best handle keyboard events?\n\n\n  function normalizeNativeEvent(nativeEvent) {\n    if (!nativeEvent || nativeEvent._normalized) {\n      return nativeEvent;\n    }\n\n    var eventType = nativeEvent.type || '';\n    var mouse = eventType.indexOf('mouse') >= 0;\n\n    if (mouse) {\n      return normalizeMouseEvent(nativeEvent);\n    } else {\n      return normalizeTouchEvent(nativeEvent);\n    }\n  }\n\n  // based on https://github.com/facebook/react/pull/4303/files\n  var ResponderEventPlugin = ReactDOMUnstableNativeDependencies__default.ResponderEventPlugin,\n      ResponderTouchHistoryStore = ReactDOMUnstableNativeDependencies__default.ResponderTouchHistoryStore; // On older versions of React (< 16.4) we have to inject the dependencies in\n  // order for the plugin to work properly in the browser. This version still\n  // uses `top*` strings to identify the internal event names.\n  // https://github.com/facebook/react/pull/12629\n\n  var types = ResponderEventPlugin.eventTypes;\n\n  if (!types.responderMove.dependencies) {\n    var endDependencies = ['topTouchCancel', 'topTouchEnd', 'topMouseUp'];\n    var moveDependencies = ['topTouchMove', 'topMouseMove'];\n    var startDependencies = ['topTouchStart', 'topMouseDown'];\n    /**\n     * Setup ResponderEventPlugin dependencies\n     */\n\n    types.responderMove.dependencies = moveDependencies;\n    types.responderEnd.dependencies = endDependencies;\n    types.responderStart.dependencies = startDependencies;\n    types.responderRelease.dependencies = endDependencies;\n    types.responderTerminationRequest.dependencies = [];\n    types.responderGrant.dependencies = [];\n    types.responderReject.dependencies = [];\n    types.responderTerminate.dependencies = [];\n    types.moveShouldSetResponder.dependencies = moveDependencies;\n    types.selectionChangeShouldSetResponder.dependencies = ['topSelectionChange'];\n    types.scrollShouldSetResponder.dependencies = ['topScroll'];\n    types.startShouldSetResponder.dependencies = startDependencies;\n  }\n\n  var lastActiveTouchTimestamp = null;\n  var originalExtractEvents = ResponderEventPlugin.extractEvents;\n\n  ResponderEventPlugin.extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var hasActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches > 0;\n    var eventType = nativeEvent.type;\n    var shouldSkipMouseAfterTouch = false;\n\n    if (eventType.indexOf('touch') > -1) {\n      lastActiveTouchTimestamp = Date.now();\n    } else if (lastActiveTouchTimestamp && eventType.indexOf('mouse') > -1) {\n      var now = Date.now();\n      shouldSkipMouseAfterTouch = now - lastActiveTouchTimestamp < 250;\n    }\n\n    if ( // Filter out mousemove and mouseup events when a touch hasn't started yet\n    (eventType === 'mousemove' || eventType === 'mouseup') && !hasActiveTouches || // Filter out events from wheel/middle and right click.\n    nativeEvent.button === 1 || nativeEvent.button === 2 || // Filter out mouse events that browsers dispatch immediately after touch events end\n    // Prevents the REP from calling handlers twice for touch interactions.\n    // See #802 and #932.\n    shouldSkipMouseAfterTouch) {\n      return;\n    }\n\n    var normalizedEvent = normalizeNativeEvent(nativeEvent);\n    return originalExtractEvents.call(ResponderEventPlugin, topLevelType, targetInst, normalizedEvent, nativeEventTarget);\n  };\n\n  ReactDOMUnstableNativeDependencies.injectEventPluginsByName({\n    ResponderEventPlugin: ResponderEventPlugin\n  });\n\n  return PanResponder;\n\n})));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACC,WAAUA,MAAM,EAAEC,OAAO,EAAE;EAC1B,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,CAACD,OAAO,GAAGD,OAAO,CAACG,OAAO,CAAC,wCAAwC,CAAC,CAAC,GAC1I,OAAOC,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,GAAGD,MAAM,CAAC,CAAC,wCAAwC,CAAC,EAAEJ,OAAO,CAAC,GACvGD,MAAM,CAACO,YAAY,GAAGN,OAAO,CAACD,MAAM,CAACQ,oBAAoB,CAAE;AAC9D,CAAC,EAAC,IAAI,EAAG,UAAUC,kCAAkC,EAAE;EAAE,YAAY;;EAEnE,IAAIC,2CAA2C,GAAG,SAAS,IAAID,kCAAkC,GAAGA,kCAAkC,CAAC,SAAS,CAAC,GAAGA,kCAAkC;;EAEtL;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIE,oBAAoB,GAAG,SAASA,oBAAoB,CAACC,EAAE,EAAEC,OAAO,EAAE;IACpE,OAAOC,UAAU,CAAC,YAAY;MAC5B,IAAIC,KAAK,GAAGC,IAAI,CAACC,GAAG,EAAE;MACtBL,EAAE,CAAC;QACDM,UAAU,EAAE,KAAK;QACjBC,aAAa,EAAE,SAASA,aAAa,GAAG;UACtC,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,IAAIL,IAAI,CAACC,GAAG,EAAE,GAAGF,KAAK,CAAC,CAAC;QAC/C;MACF,CAAC,CAAC;IACJ,CAAC,EAAE,CAAC,CAAC;EACP,CAAC;EAED,IAAIO,mBAAmB,GAAG,SAASA,mBAAmB,CAACC,EAAE,EAAE;IACzDC,YAAY,CAACD,EAAE,CAAC;EAClB,CAAC;EAED,IAAIE,WAAW,GAAG,OAAOC,MAAM,CAACC,mBAAmB,KAAK,WAAW;EACnE,IAAIA,mBAAmB,GAAGF,WAAW,GAAGC,MAAM,CAACC,mBAAmB,GAAGhB,oBAAoB;EACzF,IAAIiB,kBAAkB,GAAGH,WAAW,GAAGC,MAAM,CAACE,kBAAkB,GAAGN,mBAAmB;;EAEtF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIO,kBAAkB,GAAG;IACvBC,MAAM,EAAE;MACNC,gBAAgB,EAAE,kBAAkB;MACpCC,mBAAmB,EAAE;IACvB,CAAC;IAED;AACJ;AACA;IACIC,oBAAoB,EAAE,SAASA,oBAAoB,CAACC,IAAI,EAAE;MACxD,IAAIC,MAAM;MACV,IAAIC,OAAO,GAAG,IAAIC,OAAO,CAAC,UAAUC,OAAO,EAAE;QAC3CH,MAAM,GAAGR,mBAAmB,CAAC,YAAY;UACvC,IAAIO,IAAI,EAAE;YACRI,OAAO,CAACJ,IAAI,EAAE,CAAC;UACjB;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;MACF,OAAO;QACLK,IAAI,EAAEH,OAAO,CAACG,IAAI,CAACC,IAAI,CAACJ,OAAO,CAAC;QAChCK,IAAI,EAAEL,OAAO,CAACG,IAAI,CAACC,IAAI,CAACJ,OAAO,CAAC;QAChCM,MAAM,EAAE,SAASA,MAAM,GAAG;UACxBd,kBAAkB,CAACO,MAAM,CAAC;QAC5B;MACF,CAAC;IACH,CAAC;IAED;AACJ;AACA;IACIQ,uBAAuB,EAAE,SAASA,uBAAuB,GAAG;MAC1D,OAAO,CAAC;IACV,CAAC;IAED;AACJ;AACA;IACIC,sBAAsB,EAAE,SAASA,sBAAsB,CAACT,MAAM,EAAE;MAC9D,CAACA,MAAM,IAAIU,OAAO,CAACC,IAAI,CAAC,iCAAiC,CAAC;IAC5D,CAAC;IACDC,WAAW,EAAE,SAASA,WAAW,GAAG,CAAC;EACvC,CAAC;EAED,IAAIC,gBAAgB,GAAG;IACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIC,iBAAiB,EAAE,SAASA,iBAAiB,CAACC,YAAY,EAAEC,mBAAmB,EAAEC,OAAO,EAAEC,SAAS,EAAE;MACnG,IAAIC,SAAS,GAAGJ,YAAY,CAACI,SAAS;MACtC,IAAIC,KAAK,GAAG,CAAC;MACb,IAAIC,KAAK,GAAG,CAAC;MACb,IAAIC,YAAY,GAAGP,YAAY,CAACQ,mBAAmB,KAAK,CAAC,GAAGR,YAAY,CAACI,SAAS,CAACJ,YAAY,CAACS,wBAAwB,CAAC,GAAG,IAAI;MAEhI,IAAIF,YAAY,KAAK,IAAI,EAAE;QACzB,IAAIA,YAAY,CAACG,WAAW,IAAIH,YAAY,CAACI,gBAAgB,GAAGV,mBAAmB,EAAE;UACnFI,KAAK,IAAIF,SAAS,IAAID,OAAO,GAAGK,YAAY,CAACK,YAAY,GAAGT,SAAS,IAAI,CAACD,OAAO,GAAGK,YAAY,CAACM,YAAY,GAAG,CAACV,SAAS,IAAID,OAAO,GAAGK,YAAY,CAACO,aAAa,GAAGP,YAAY,CAACQ,aAAa;UAC/LT,KAAK,GAAG,CAAC;QACX;MACF,CAAC,MAAM;QACL,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;UACzC,IAAIE,UAAU,GAAGd,SAAS,CAACY,CAAC,CAAC;UAE7B,IAAIE,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAKC,SAAS,IAAID,UAAU,CAACR,WAAW,IAAIQ,UAAU,CAACP,gBAAgB,IAAIV,mBAAmB,EAAE;YACnI,IAAImB,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC;;YAEpB,IAAIjB,SAAS,IAAID,OAAO,EAAE;cACxBkB,KAAK,GAAGF,UAAU,CAACN,YAAY;YACjC,CAAC,MAAM,IAAIT,SAAS,IAAI,CAACD,OAAO,EAAE;cAChCkB,KAAK,GAAGF,UAAU,CAACL,YAAY;YACjC,CAAC,MAAM,IAAI,CAACV,SAAS,IAAID,OAAO,EAAE;cAChCkB,KAAK,GAAGF,UAAU,CAACJ,aAAa;YAClC,CAAC,MAAM;cACLM,KAAK,GAAGF,UAAU,CAACH,aAAa;YAClC;YAEAV,KAAK,IAAIe,KAAK;YACdd,KAAK,EAAE;UACT;QACF;MACF;MAEA,OAAOA,KAAK,GAAG,CAAC,GAAGD,KAAK,GAAGC,KAAK,GAAGR,gBAAgB,CAACuB,UAAU;IAChE,CAAC;IACDC,qCAAqC,EAAE,SAASA,qCAAqC,CAACtB,YAAY,EAAEC,mBAAmB,EAAE;MACvH,OAAOH,gBAAgB,CAACC,iBAAiB,CAACC,YAAY,EAAEC,mBAAmB,EAAE,IAAI;MAAE;MACnF,IAAI,CAAC;IACP,CAAC;IACDsB,qCAAqC,EAAE,SAASA,qCAAqC,CAACvB,YAAY,EAAEC,mBAAmB,EAAE;MACvH,OAAOH,gBAAgB,CAACC,iBAAiB,CAACC,YAAY,EAAEC,mBAAmB,EAAE,KAAK;MAAE;MACpF,IAAI,CAAC;IACP,CAAC;IACDuB,sCAAsC,EAAE,SAASA,sCAAsC,CAACxB,YAAY,EAAEC,mBAAmB,EAAE;MACzH,OAAOH,gBAAgB,CAACC,iBAAiB,CAACC,YAAY,EAAEC,mBAAmB,EAAE,IAAI;MAAE;MACnF,KAAK,CAAC;IACR,CAAC;IACDwB,sCAAsC,EAAE,SAASA,sCAAsC,CAACzB,YAAY,EAAEC,mBAAmB,EAAE;MACzH,OAAOH,gBAAgB,CAACC,iBAAiB,CAACC,YAAY,EAAEC,mBAAmB,EAAE,KAAK;MAAE;MACpF,KAAK,CAAC;IACR,CAAC;IACDyB,gBAAgB,EAAE,SAASA,gBAAgB,CAAC1B,YAAY,EAAE;MACxD,OAAOF,gBAAgB,CAACC,iBAAiB,CAACC,YAAY,EAAE,CAAC;MAAE;MAC3D,IAAI;MAAE;MACN,IAAI,CAAC;IACP,CAAC;IACD2B,gBAAgB,EAAE,SAASA,gBAAgB,CAAC3B,YAAY,EAAE;MACxD,OAAOF,gBAAgB,CAACC,iBAAiB,CAACC,YAAY,EAAE,CAAC;MAAE;MAC3D,KAAK;MAAE;MACP,IAAI,CAAC;IACP,CAAC;IACDqB,UAAU,EAAE,CAAC;EACf,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAIC,qCAAqC,GAAGxB,gBAAgB,CAACwB,qCAAqC;EAClG,IAAIC,qCAAqC,GAAGzB,gBAAgB,CAACyB,qCAAqC;EAClG,IAAIC,sCAAsC,GAAG1B,gBAAgB,CAAC0B,sCAAsC;EACpG,IAAIC,sCAAsC,GAAG3B,gBAAgB,CAAC2B,sCAAsC;EACpG,IAAIC,gBAAgB,GAAG5B,gBAAgB,CAAC4B,gBAAgB;EACxD,IAAIC,gBAAgB,GAAG7B,gBAAgB,CAAC6B,gBAAgB;EACxD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,IAAItE,YAAY,GAAG;IACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIuE,uBAAuB,EAAE,SAASA,uBAAuB,CAACC,YAAY,EAAE;MACtEA,YAAY,CAACC,KAAK,GAAG,CAAC;MACtBD,YAAY,CAACE,KAAK,GAAG,CAAC;MACtBF,YAAY,CAACG,EAAE,GAAG,CAAC;MACnBH,YAAY,CAACI,EAAE,GAAG,CAAC;MACnBJ,YAAY,CAACK,EAAE,GAAG,CAAC;MACnBL,YAAY,CAACM,EAAE,GAAG,CAAC;MACnBN,YAAY,CAACO,EAAE,GAAG,CAAC;MACnBP,YAAY,CAACQ,EAAE,GAAG,CAAC;MACnBR,YAAY,CAACrB,mBAAmB,GAAG,CAAC,CAAC,CAAC;;MAEtCqB,YAAY,CAACS,qBAAqB,GAAG,CAAC;IACxC,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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"},"metadata":{},"sourceType":"script"}