{"ast":null,"code":"const PanResponder = require('react-panresponder-web');\nconst React = require('react');\nconst {\n  useSpring,\n  animated\n} = require('@react-spring/web');\nconst height = window.innerHeight;\nconst width = window.innerWidth;\nconst settings = {\n  maxTilt: 25,\n  // in deg\n  rotationPower: 50,\n  swipeThreshold: 0.5 // need to update this threshold for RN (1.5 seems reasonable...?)\n};\n\n// physical properties of the spring\nconst physics = {\n  touchResponsive: {\n    friction: 50,\n    tension: 2000\n  },\n  animateOut: {\n    friction: 30,\n    tension: 400\n  },\n  animateBack: {\n    friction: 10,\n    tension: 200\n  }\n};\nconst pythagoras = (x, y) => {\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n};\nconst normalize = vector => {\n  const length = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n  return {\n    x: vector.x / length,\n    y: vector.y / length\n  };\n};\nconst animateOut = async (gesture, setSpringTarget) => {\n  const diagonal = pythagoras(height, width);\n  const velocity = pythagoras(gesture.x, gesture.y);\n  const finalX = diagonal * gesture.x;\n  const finalY = diagonal * gesture.y;\n  const finalRotation = gesture.x * 45;\n  const duration = diagonal / velocity;\n  setSpringTarget.start({\n    xyrot: [finalX, finalY, finalRotation],\n    config: {\n      duration: duration\n    }\n  });\n\n  // for now animate back\n  return await new Promise(resolve => setTimeout(() => {\n    resolve();\n  }, duration));\n};\nconst animateBack = setSpringTarget => {\n  // translate back to the initial position\n  return new Promise(resolve => {\n    setSpringTarget.start({\n      xyrot: [0, 0, 0],\n      config: physics.animateBack,\n      onRest: resolve\n    });\n  });\n};\nconst getSwipeDirection = property => {\n  if (Math.abs(property.x) > Math.abs(property.y)) {\n    if (property.x > settings.swipeThreshold) {\n      return 'right';\n    } else if (property.x < -settings.swipeThreshold) {\n      return 'left';\n    }\n  } else {\n    if (property.y > settings.swipeThreshold) {\n      return 'down';\n    } else if (property.y < -settings.swipeThreshold) {\n      return 'up';\n    }\n  }\n  return 'none';\n};\n\n// must be created outside of the TinderCard forwardRef\nconst AnimatedDiv = animated.div;\nconst TinderCard = React.forwardRef((_ref, ref) => {\n  let {\n    flickOnSwipe = true,\n    children,\n    onSwipe,\n    onCardLeftScreen,\n    className,\n    preventSwipe = [],\n    swipeRequirementType = 'velocity',\n    swipeThreshold = settings.swipeThreshold,\n    onSwipeRequirementFulfilled,\n    onSwipeRequirementUnfulfilled\n  } = _ref;\n  const [{\n    xyrot\n  }, setSpringTarget] = useSpring(() => ({\n    xyrot: [0, 0, 0],\n    config: physics.touchResponsive\n  }));\n  settings.swipeThreshold = swipeThreshold;\n  React.useImperativeHandle(ref, () => ({\n    async swipe() {\n      let dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'right';\n      if (onSwipe) onSwipe(dir);\n      const power = 1.3;\n      const disturbance = (Math.random() - 0.5) / 2;\n      if (dir === 'right') {\n        await animateOut({\n          x: power,\n          y: disturbance\n        }, setSpringTarget);\n      } else if (dir === 'left') {\n        await animateOut({\n          x: -power,\n          y: disturbance\n        }, setSpringTarget);\n      } else if (dir === 'up') {\n        await animateOut({\n          x: disturbance,\n          y: power\n        }, setSpringTarget);\n      } else if (dir === 'down') {\n        await animateOut({\n          x: disturbance,\n          y: -power\n        }, setSpringTarget);\n      }\n      if (onCardLeftScreen) onCardLeftScreen(dir);\n    },\n    async restoreCard() {\n      await animateBack(setSpringTarget);\n    }\n  }));\n  const handleSwipeReleased = React.useCallback(async (setSpringTarget, gesture) => {\n    // Check if this is a swipe\n    const dir = getSwipeDirection({\n      x: swipeRequirementType === 'velocity' ? gesture.vx : gesture.dx,\n      y: swipeRequirementType === 'velocity' ? gesture.vy : gesture.dy\n    });\n    if (dir !== 'none') {\n      if (flickOnSwipe) {\n        if (!preventSwipe.includes(dir)) {\n          if (onSwipe) onSwipe(dir);\n          await animateOut(swipeRequirementType === 'velocity' ? {\n            x: gesture.vx,\n            y: gesture.vy\n          } : normalize({\n            x: gesture.dx,\n            y: gesture.dy\n          }) // Normalize to avoid flicking the card away with super fast speed only direction is wanted here\n          , setSpringTarget, swipeRequirementType);\n          if (onCardLeftScreen) onCardLeftScreen(dir);\n          return;\n        }\n      }\n    }\n\n    // Card was not flicked away, animate back to start\n    animateBack(setSpringTarget);\n  }, [swipeRequirementType, flickOnSwipe, preventSwipe, onSwipe, onCardLeftScreen]);\n  let swipeThresholdFulfilledDirection = 'none';\n  const panResponder = React.useMemo(() => PanResponder.create({\n    // Ask to be the responder:\n    onStartShouldSetPanResponder: (evt, gestureState) => true,\n    onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\n    onMoveShouldSetPanResponder: (evt, gestureState) => true,\n    onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\n    onPanResponderGrant: (evt, gestureState) => {\n      // The gesture has started.\n      // Probably wont need this anymore as postion i relative to swipe!\n      setSpringTarget.start({\n        xyrot: [gestureState.dx, gestureState.dy, 0],\n        config: physics.touchResponsive\n      });\n    },\n    onPanResponderMove: (evt, gestureState) => {\n      // Check fulfillment\n      if (onSwipeRequirementFulfilled || onSwipeRequirementUnfulfilled) {\n        const dir = getSwipeDirection({\n          x: swipeRequirementType === 'velocity' ? gestureState.vx : gestureState.dx,\n          y: swipeRequirementType === 'velocity' ? gestureState.vy : gestureState.dy\n        });\n        if (dir !== swipeThresholdFulfilledDirection) {\n          swipeThresholdFulfilledDirection = dir;\n          if (swipeThresholdFulfilledDirection === 'none') {\n            if (onSwipeRequirementUnfulfilled) onSwipeRequirementUnfulfilled();\n          } else {\n            if (onSwipeRequirementFulfilled) onSwipeRequirementFulfilled(dir);\n          }\n        }\n      }\n\n      // use guestureState.vx / guestureState.vy for velocity calculations\n      // translate element\n      let rot = 300 * gestureState.vx / width * 15; // Magic number 300 different on different devices? Run on physical device!\n      rot = Math.max(Math.min(rot, settings.maxTilt), -settings.maxTilt);\n      setSpringTarget.start({\n        xyrot: [gestureState.dx, gestureState.dy, rot],\n        config: physics.touchResponsive\n      });\n    },\n    onPanResponderTerminationRequest: (evt, gestureState) => {\n      return true;\n    },\n    onPanResponderRelease: (evt, gestureState) => {\n      // The user has released all touches while this view is the\n      // responder. This typically means a gesture has succeeded\n      // enable\n      handleSwipeReleased(setSpringTarget, gestureState);\n    }\n  }), []);\n  const element = React.useRef();\n  React.useLayoutEffect(() => {\n    element.current.addEventListener('touchstart', ev => {\n      if (!ev.srcElement.className.includes('pressable') && ev.cancelable) {\n        ev.preventDefault();\n      }\n    });\n  });\n  return React.createElement(AnimatedDiv, {\n    ref: element,\n    className,\n    ...panResponder.panHandlers,\n    style: {\n      transform: xyrot.to((x, y, rot) => `translate3d(${x}px, ${y}px, ${0}px) rotate(${rot}deg)`)\n    },\n    children\n  });\n});\nmodule.exports = TinderCard;","map":{"version":3,"names":["PanResponder","require","React","useSpring","animated","height","window","innerHeight","width","innerWidth","settings","maxTilt","rotationPower","swipeThreshold","physics","touchResponsive","friction","tension","animateOut","animateBack","pythagoras","x","y","Math","sqrt","pow","normalize","vector","length","gesture","setSpringTarget","diagonal","velocity","finalX","finalY","finalRotation","duration","start","xyrot","config","Promise","resolve","setTimeout","onRest","getSwipeDirection","property","abs","AnimatedDiv","div","TinderCard","forwardRef","ref","flickOnSwipe","children","onSwipe","onCardLeftScreen","className","preventSwipe","swipeRequirementType","onSwipeRequirementFulfilled","onSwipeRequirementUnfulfilled","useImperativeHandle","swipe","dir","power","disturbance","random","restoreCard","handleSwipeReleased","useCallback","vx","dx","vy","dy","includes","swipeThresholdFulfilledDirection","panResponder","useMemo","create","onStartShouldSetPanResponder","evt","gestureState","onStartShouldSetPanResponderCapture","onMoveShouldSetPanResponder","onMoveShouldSetPanResponderCapture","onPanResponderGrant","onPanResponderMove","rot","max","min","onPanResponderTerminationRequest","onPanResponderRelease","element","useRef","useLayoutEffect","current","addEventListener","ev","srcElement","cancelable","preventDefault","createElement","panHandlers","style","transform","to","module","exports"],"sources":["/Users/sethstephens/Desktop/fureverv4/furever/Client/node_modules/react-tinder-card/index.js"],"sourcesContent":["const PanResponder = require('react-panresponder-web')\nconst React = require('react')\nconst { useSpring, animated } = require('@react-spring/web')\n\nconst height = window.innerHeight\nconst width = window.innerWidth\n\nconst settings = {\n  maxTilt: 25, // in deg\n  rotationPower: 50,\n  swipeThreshold: 0.5 // need to update this threshold for RN (1.5 seems reasonable...?)\n}\n\n// physical properties of the spring\nconst physics = {\n  touchResponsive: {\n    friction: 50,\n    tension: 2000\n  },\n  animateOut: {\n    friction: 30,\n    tension: 400\n  },\n  animateBack: {\n    friction: 10,\n    tension: 200\n  }\n}\n\nconst pythagoras = (x, y) => {\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))\n}\n\nconst normalize = (vector) => {\n  const length = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2))\n  return { x: vector.x / length, y: vector.y / length }\n}\n\nconst animateOut = async (gesture, setSpringTarget) => {\n  const diagonal = pythagoras(height, width)\n  const velocity = pythagoras(gesture.x, gesture.y)\n  const finalX = diagonal * gesture.x\n  const finalY = diagonal * gesture.y\n  const finalRotation = gesture.x * 45\n  const duration = diagonal / velocity\n\n  setSpringTarget.start({\n    xyrot: [finalX, finalY, finalRotation],\n    config: { duration: duration }\n  })\n\n  // for now animate back\n  return await new Promise((resolve) =>\n    setTimeout(() => {\n      resolve()\n    }, duration)\n  )\n}\n\nconst animateBack = (setSpringTarget) => {\n  // translate back to the initial position\n  return new Promise((resolve) => {\n    setSpringTarget.start({ xyrot: [0, 0, 0], config: physics.animateBack, onRest: resolve })\n  })\n}\n\nconst getSwipeDirection = (property) => {\n  if (Math.abs(property.x) > Math.abs(property.y)) {\n    if (property.x > settings.swipeThreshold) {\n      return 'right'\n    } else if (property.x < -settings.swipeThreshold) {\n      return 'left'\n    }\n  } else {\n    if (property.y > settings.swipeThreshold) {\n      return 'down'\n    } else if (property.y < -settings.swipeThreshold) {\n      return 'up'\n    }\n  }\n  return 'none'\n}\n\n// must be created outside of the TinderCard forwardRef\nconst AnimatedDiv = animated.div\n\nconst TinderCard = React.forwardRef(\n  (\n    { flickOnSwipe = true, children, onSwipe, onCardLeftScreen, className, preventSwipe = [], swipeRequirementType = 'velocity', swipeThreshold = settings.swipeThreshold, onSwipeRequirementFulfilled, onSwipeRequirementUnfulfilled },\n    ref\n  ) => {\n    const [{ xyrot }, setSpringTarget] = useSpring(() => ({\n      xyrot: [0, 0, 0],\n      config: physics.touchResponsive\n    }))\n\n    settings.swipeThreshold = swipeThreshold\n\n    React.useImperativeHandle(ref, () => ({\n      async swipe (dir = 'right') {\n        if (onSwipe) onSwipe(dir)\n        const power = 1.3\n        const disturbance = (Math.random() - 0.5) / 2\n        if (dir === 'right') {\n          await animateOut({ x: power, y: disturbance }, setSpringTarget)\n        } else if (dir === 'left') {\n          await animateOut({ x: -power, y: disturbance }, setSpringTarget)\n        } else if (dir === 'up') {\n          await animateOut({ x: disturbance, y: power }, setSpringTarget)\n        } else if (dir === 'down') {\n          await animateOut({ x: disturbance, y: -power }, setSpringTarget)\n        }\n        if (onCardLeftScreen) onCardLeftScreen(dir)\n      },\n      async restoreCard () {\n        await animateBack(setSpringTarget)\n      }\n    }))\n\n    const handleSwipeReleased = React.useCallback(\n      async (setSpringTarget, gesture) => {\n        // Check if this is a swipe\n        const dir = getSwipeDirection({\n          x: swipeRequirementType === 'velocity' ? gesture.vx : gesture.dx,\n          y: swipeRequirementType === 'velocity' ? gesture.vy : gesture.dy\n        })\n\n        if (dir !== 'none') {\n          if (flickOnSwipe) {\n            if (!preventSwipe.includes(dir)) {\n              if (onSwipe) onSwipe(dir)\n\n              await animateOut(swipeRequirementType === 'velocity' ? ({\n                x: gesture.vx,\n                y: gesture.vy\n              }) : (\n                normalize({ x: gesture.dx, y: gesture.dy }) // Normalize to avoid flicking the card away with super fast speed only direction is wanted here\n              ), setSpringTarget, swipeRequirementType)\n              if (onCardLeftScreen) onCardLeftScreen(dir)\n              return\n            }\n          }\n        }\n\n        // Card was not flicked away, animate back to start\n        animateBack(setSpringTarget)\n      },\n      [swipeRequirementType, flickOnSwipe, preventSwipe, onSwipe, onCardLeftScreen]\n    )\n\n    let swipeThresholdFulfilledDirection = 'none'\n    const panResponder = React.useMemo(\n      () =>\n        PanResponder.create({\n          // Ask to be the responder:\n          onStartShouldSetPanResponder: (evt, gestureState) => true,\n          onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\n          onMoveShouldSetPanResponder: (evt, gestureState) => true,\n          onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\n\n          onPanResponderGrant: (evt, gestureState) => {\n            // The gesture has started.\n            // Probably wont need this anymore as postion i relative to swipe!\n            setSpringTarget.start({ xyrot: [gestureState.dx, gestureState.dy, 0], config: physics.touchResponsive })\n          },\n          onPanResponderMove: (evt, gestureState) => {\n            // Check fulfillment\n            if (onSwipeRequirementFulfilled || onSwipeRequirementUnfulfilled) {\n              const dir = getSwipeDirection({\n                x: swipeRequirementType === 'velocity' ? gestureState.vx : gestureState.dx,\n                y: swipeRequirementType === 'velocity' ? gestureState.vy : gestureState.dy\n              })\n              if (dir !== swipeThresholdFulfilledDirection) {\n                swipeThresholdFulfilledDirection = dir\n                if (swipeThresholdFulfilledDirection === 'none') {\n                  if (onSwipeRequirementUnfulfilled) onSwipeRequirementUnfulfilled()\n                } else {\n                  if (onSwipeRequirementFulfilled) onSwipeRequirementFulfilled(dir)\n                }\n              }\n            }\n\n            // use guestureState.vx / guestureState.vy for velocity calculations\n            // translate element\n            let rot = ((300 * gestureState.vx) / width) * 15// Magic number 300 different on different devices? Run on physical device!\n            rot = Math.max(Math.min(rot, settings.maxTilt), -settings.maxTilt)\n            setSpringTarget.start({ xyrot: [gestureState.dx, gestureState.dy, rot], config: physics.touchResponsive })\n          },\n          onPanResponderTerminationRequest: (evt, gestureState) => {\n            return true\n          },\n          onPanResponderRelease: (evt, gestureState) => {\n            // The user has released all touches while this view is the\n            // responder. This typically means a gesture has succeeded\n            // enable\n            handleSwipeReleased(setSpringTarget, gestureState)\n          }\n        }),\n      []\n    )\n\n    const element = React.useRef()\n\n    React.useLayoutEffect(() => {\n      element.current.addEventListener(('touchstart'), (ev) => {\n        if (!ev.srcElement.className.includes('pressable') && ev.cancelable) {\n          ev.preventDefault()\n        }\n      })\n    })\n\n    return (\n      React.createElement(AnimatedDiv, {\n        ref: element,\n        className,\n        ...panResponder.panHandlers,\n        style: {\n          transform: xyrot.to((x, y, rot) => `translate3d(${x}px, ${y}px, ${0}px) rotate(${rot}deg)`)\n        },\n        children\n      })\n    )\n  }\n)\n\nmodule.exports = TinderCard\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}